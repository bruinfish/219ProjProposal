\documentclass[journal]{IEEEtran}

\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}

\title{Distribtued Computation over NDN-based Data Center Network}

\author{Zhiyang Wang,
        Cheng-Kang Hsieh,
        and Yingdi Yu}

\maketitle

\begin{abstract}
The abstract goes here.
\end{abstract}

\begin{IEEEkeywords}
Data Center Network, NDN, Distributed Computation
\end{IEEEkeywords}

\IEEEpeerreviewmaketitle



\section{Introduction}
\IEEEPARstart{D}{ata}-intensive distributed computing has been a major challenge
in data centers for a long time.  Without well-managed data and computation, a
large portion of computations in a data center have to be unnecessarily
repeated.  In order to avoid redundant computation, Pradeep, {\it et al.}
proposed Nectar \cite{gunda2010nectar}, a system in which intermediate computation
results can be cached so that they can be reused by following computation.
Evaluation results suggested that caching intermediate results can save at most
99\% redundant computations in some cases \cite{gunda2010nectar}.

However, there are still several unresolved issues in caching intermediate
computation results in current data center network.  First, a centralized cache
server, as proposed by Nectar, may become a hot spot when computing
significantly relies on cached intermediate results.  Second, when several
computing servers need to re-use the same cached intermediate result, they have
to fetch the cached data individually from the cache server.  Such a data
communication mode may work in some small-volume data-exchanging and highly
distributed system (e.g. DNS), but may become inefficient in data center network
where data exchanged are much more bigger and computing servers are relatively
close to each other in terms of network topology.

Named-Data Network \cite{jacobson2009networking}, a novel network architecture
which can cache data inside networks instead of servers, appears to be a
potential solution to the problems mentioned above.  In NDN, data are named and
fetch by their names, rather than through a end-to-end connection between a
requester and a data provider.  With a specific name, a data packet can be
cached along the path (more specifically speaking, NDN routers) it has traveled
through.  When some other requesters ask for the same data, the request can be
satisfied by data cached in NDN routers without reaching the corresponding data
provider.  In this way, NDN intrinsically provides a distributed caching
service, and avoids end-to-end connections. 

Although NDN has many attractive features, it is not very feasible to provide
intermediate computation results caching service in NDN.  There are two open
questions: 1) how to name intermediate computation results to maximize the
caching efficiency and 2) what is the best network topology for NDN-based data
center network.  These two issues will be discussed in detail in Section
\ref{sec:problem_statement}.

In this project, we plan to answer the two questions above by building a
prototype of NDN-based data center network.  In order to evaluate the
performance of the prototype, we will provide two specific applications
supported by the prototype: 1) simple SQL query in a distributed database and 2)
distributed word occurance analysis.  As we will describe in Section
\ref{sec:problem_statement}, each application represents a different type of
distributed data computing: incremental computing and sub-computing
respectively.  We will also compare the performance of our prototype with the
existing IP-based solution, Nectar, and try to derive some general conclusions
which can be used for future data center network designs.

\section{Problem Statement}\label{sec:problem_statement}
To make the problem discussion more clear, we first describe two applications
that will be implemented over our prototype. And then two related issues will be
discussed in detail.

The first application is a simple SQL query in a distributed database.  In this
database, data are stored on multiple servers in a distributed way, and queries
are processed in a MapReduce style.  When a query is issued, related entries
will be grouped by mapers, and then further processed by reducers.  When new
entries have been injected into the database, all related entries have to be
re-grouped if intermediate results caching is not used.  When the grouped
entries can be cached as intermediate results, mapers only need to group
recently injected entries which can be combined with cached results for reducer
to process.  Such a computing mode is called as incremental computing.  

The second application is a distributed word occurance analysis.  Unlike the
previous application, data set is persistent in this application.  In order to
get the final results, the computation can be divided into several steps.  Some
steps may require the computation results of some other steps.  And the same
computation results may be re-used by more than one computing servers.  Such a
computing mode is called as sub-computing.

\subsection{Name Intermediate Results}
We use the first application to discuss the naming issue in NDN-based network.
In traditional IP network, a maper will transfer data to a reducer, while in
NDN, a reducer is notified a task, and then fetches data needed for the task.
The reducer issues an {\sc Interest} message which contains the name of
requested data.  The name should be able to represent the timeliness of the
task.  For example, if a reducer needs all the grouped entries before a
timestamp $t_i$, and there are several pieces of entries injected at timestamps
$t_{i-3}$, $t_{i-2}$, $t_{i-1}$ before $t_i$, then all intermediate grouped
entries, if cached, should be able to be matched with a name containing the
timestamp $t_i$.  However, the sequential nature of timestamp conflicts with the
hierarchical structure of NDN's naming mechanism which determines caching
efficiency to a large extent. Therefore, we have to find a compatible naming
mechanism for incremental computing.
\subsection{Network Topology}
\subsection{Comparison With IP-based Solution}
\section{Related Work}
\section{Timeline}

\bibliographystyle{abbrv}
\bibliography{proposal}

%\begin{thebibliography}{1}
%\bibitem{2010osdiGunda}
%Nectar
%\end{thebibliography}
\end{document}


